/*
 * ShellSmartPayAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.apitest.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.shell.apitest.ApiHelper;
import com.shell.apitest.Server;
import com.shell.apitest.exceptions.ApiException;
import com.shell.apitest.exceptions.CancelFuelingErrorResponseErrorException;
import com.shell.apitest.exceptions.MppAccesTokenErrorResponseException;
import com.shell.apitest.http.request.HttpMethod;
import com.shell.apitest.models.MppAccesTokenResponse;
import com.shell.apitest.models.PrepareFuelingRequest;
import com.shell.apitest.models.PrepareFuelingResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class FuelingController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public FuelingController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * The Digital Payments Service enables 3rd Parties to trigger the refuel process which, if
     * successful, will unlock a pump/nozzle ready for fuelling. Enables a 3rd party to request an
     * access token to start using fueling. APIs.
     * @param  grantType  Required parameter: In OAuth 2.0, the term grant type refers to the way an
     *         application gets an access token. OAuth 2.0 defines several grant types, including
     *         the authorization code flow.
     * @param  clientId  Required parameter: After registering your app, you will receive a client
     *         ID and a client secret. The client ID is considered public information, and is used
     *         to build login URLs, or included in Javascript source code on a page.
     * @param  clientSecret  Required parameter: After registering your app, you will receive a
     *         client ID and a client secret. The client ID is considered public information, and is
     *         used to build login URLs, or included in Javascript source code on a page. The client
     *         secret must be kept confidential.
     * @return    Returns the MppAccesTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public MppAccesTokenResponse mppToken(
            final String grantType,
            final String clientId,
            final String clientSecret) throws ApiException, IOException {
        return prepareMppTokenRequest(grantType, clientId, clientSecret).execute();
    }

    /**
     * The Digital Payments Service enables 3rd Parties to trigger the refuel process which, if
     * successful, will unlock a pump/nozzle ready for fuelling. Enables a 3rd party to request an
     * access token to start using fueling. APIs.
     * @param  grantType  Required parameter: In OAuth 2.0, the term grant type refers to the way an
     *         application gets an access token. OAuth 2.0 defines several grant types, including
     *         the authorization code flow.
     * @param  clientId  Required parameter: After registering your app, you will receive a client
     *         ID and a client secret. The client ID is considered public information, and is used
     *         to build login URLs, or included in Javascript source code on a page.
     * @param  clientSecret  Required parameter: After registering your app, you will receive a
     *         client ID and a client secret. The client ID is considered public information, and is
     *         used to build login URLs, or included in Javascript source code on a page. The client
     *         secret must be kept confidential.
     * @return    Returns the MppAccesTokenResponse response from the API call
     */
    public CompletableFuture<MppAccesTokenResponse> mppTokenAsync(
            final String grantType,
            final String clientId,
            final String clientSecret) {
        try { 
            return prepareMppTokenRequest(grantType, clientId, clientSecret).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for mppToken.
     */
    private ApiCall<MppAccesTokenResponse, ApiException> prepareMppTokenRequest(
            final String grantType,
            final String clientId,
            final String clientSecret) throws IOException {
        return new ApiCall.Builder<MppAccesTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/Fueling/v1/oauth/token")
                        .formParam(param -> param.key("grant_type")
                                .value(grantType))
                        .formParam(param -> param.key("client_id")
                                .value(clientId))
                        .formParam(param -> param.key("client_secret")
                                .value(clientSecret))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("oAuthTokenPost"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, MppAccesTokenResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized. The request has not been applied because it lacks valid authentication credentials for the target resource.",
                                (reason, context) -> new MppAccesTokenErrorResponseException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables a 3rd party to request to unlock a pump so that they may fill up to a pre-authorised
     * limit. The fuel types that are unlocked may also be determined by permitted fuels stored
     * against the user/entity profile.
     * @param  siteCountry  Required parameter: Country ISO code
     * @param  currency  Required parameter: Currency ISO code
     * @param  body  Required parameter: Example:
     * @return    Returns the PrepareFuelingResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PrepareFuelingResponse mppPrepareFueling(
            final String siteCountry,
            final String currency,
            final PrepareFuelingRequest body) throws ApiException, IOException {
        return prepareMppPrepareFuelingRequest(siteCountry, currency, body).execute();
    }

    /**
     * Enables a 3rd party to request to unlock a pump so that they may fill up to a pre-authorised
     * limit. The fuel types that are unlocked may also be determined by permitted fuels stored
     * against the user/entity profile.
     * @param  siteCountry  Required parameter: Country ISO code
     * @param  currency  Required parameter: Currency ISO code
     * @param  body  Required parameter: Example:
     * @return    Returns the PrepareFuelingResponse response from the API call
     */
    public CompletableFuture<PrepareFuelingResponse> mppPrepareFuelingAsync(
            final String siteCountry,
            final String currency,
            final PrepareFuelingRequest body) {
        try { 
            return prepareMppPrepareFuelingRequest(siteCountry, currency, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for mppPrepareFueling.
     */
    private ApiCall<PrepareFuelingResponse, ApiException> prepareMppPrepareFuelingRequest(
            final String siteCountry,
            final String currency,
            final PrepareFuelingRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PrepareFuelingResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/Fueling/v1/fueling")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .queryParam(param -> param.key("siteCountry")
                                .value(siteCountry))
                        .queryParam(param -> param.key("currency")
                                .value(currency))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .and(andAuth -> andAuth
                                        .add("oAuthTokenPost")
                                        .add("MppToken")))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PrepareFuelingResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Error Occurred. Request did not include bearer token or token provided and is invalid.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden. Requestor is not permitted to call the API",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found. Request received by the server but requested URL not found",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables a partner user to cancel pump reservation from the App.
     * @param  mppTransactionId  Required parameter: The ID of the transaction that’s being
     *         cancelled
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void mppCancelFueling(
            final String mppTransactionId) throws ApiException, IOException {
        prepareMppCancelFuelingRequest(mppTransactionId).execute();
    }

    /**
     * Enables a partner user to cancel pump reservation from the App.
     * @param  mppTransactionId  Required parameter: The ID of the transaction that’s being
     *         cancelled
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> mppCancelFuelingAsync(
            final String mppTransactionId) {
        try { 
            return prepareMppCancelFuelingRequest(mppTransactionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for mppCancelFueling.
     */
    private ApiCall<Void, ApiException> prepareMppCancelFuelingRequest(
            final String mppTransactionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/Fueling/v1/fueling/{mppTransactionId}")
                        .templateParam(param -> param.key("mppTransactionId").value(mppTransactionId)
                                .shouldEncode(true))
                        .withAuth(auth -> auth
                                .and(andAuth -> andAuth
                                        .add("oAuthTokenPost")
                                        .add("MppToken")))
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Error Occurred. The server cannot or will not process the request due to an apparent client error (e.g., malformed request syntax, invalid request message). Please see below for information regarding structure of Response Body vs. all possible errors that could be returned.",
                                (reason, context) -> new CancelFuelingErrorResponseErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Unauthorized. Request did not include bearer token or token provided and is invalid.",
                                (reason, context) -> new CancelFuelingErrorResponseErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden. Requestor is not permitted to call the API.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("Not Found. Request received by the server but requested URL not found",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}